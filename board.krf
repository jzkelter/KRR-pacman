(in-microtheory PacPersonMt)
(genlMt PacPersonMt QualitativeMechanicsMt)

;; ontologize

(isa wall Predicate)
(arity wall 1)
(arg1Isa wall 2DNonDiagonal)
(comment wall "(wall ?direction) says that ?direction is a wall")

(isa facing Predicate)
(arity facing 1)
(arg1Isa facing 2DNonDiagonal)
(comment facing "(facing ?direction) says that PacPerson is facing ?direction")

(isa directionToFace Predicate)
(arity directionToFace 1)
(arg1Isa directionToFace 2DNonDiagonal)
(comment directionToFace "(directionToFace ?direction) says that PacPerson should next face ?direction")

(isa nearestPellet Predicate)
(arity nearestPellet 1)
(arg1Isa nearestPellet 2DNonDiagonal)
(comment nearestPellet "(nearestPellet ?direction) says that the nearest pellet is at ?direction. If multiple pellets are the same distance away, there will be multiple of these.")

(isa nearestGhost Predicate)
(arity nearestGhost 1)
(arg1Isa nearestGhost 2DNonDiagonal)
(comment nearestGhost "(nearestGhost ?direction) says that the nearest ghost is at ?direction. If multiple ghosts are the same distance away, there will be multiple of these.")

(isa noSurroundingPellets Predicate)
(arity noSurroundingPellets 0)
(comment noSurroundingPellets "(noSurroundingPellets) says there are no pellets around PacPerson")


(<== (noSurroundingPellets)
        (uninferredSentence (nearestPellet Up))
        (uninferredSentence (nearestPellet Right))
        (uninferredSentence (nearestPellet Down))
        (uninferredSentence (nearestPellet Left))
)

(isa noAdjacentGhosts Predicate)
(arity noAdjacentGhosts 0)
(comment noAdjacentGhosts "(noAdjacentGhosts) says there are no ghosts around PacPerson")

(<== (noAdjacentGhosts)
        (uninferredSentence (ghost Up))
        (uninferredSentence (ghost Right))
        (uninferredSentence (ghost Down))
        (uninferredSentence (ghost Left))
)

(isa multipleNearestPellets Predicate)
(arity multipleNearestPellets 0)
(comment multipleNearestPellets "(multipleNearestPellets) says there are multiple equidistant nearest pellets")

(<== (multipleNearestPellets)
        (nearestPellet ?directionA)
        (nearestPellet ?directionB)
        (different ?directionA ?directionB)
)


(<== (hasMultipleOutputs ?arity1Function)
        (?arity1Function ?output1)
        (?arity1Function ?output2)
        (different ?output1 ?output2)
)

;; Priorities:
;; at each level if there's just one option then we're done
;; 1. no ghost/no wall (not blocked)
;; 2. nearestPellet
;; 3. not nearestGhost
;; 4. facing (make this #2?)

(<== (unblocked ?dir)
        (isa ?dir 2DNonDiagonal)
        (uninferredSentence (wall ?dir))
        (uninferredSentence (ghost ?dir))
)

;; CONSIDERING BLOCKED + FACING

;; There is one unblocked direction. Face it.
(<== (directionToFace ?dir)
        (unblocked ?dir)
        (uninferredSentence (hasMultipleOutputs unblocked))
)

;; You're facing an unblocked direction. Keep going.
(<== (directionToFace ?dir)
        (unblocked ?dir)
        (facing ?dir)
)

;; There is more than one unblocked direction. Think about nearest pellet.
(<== (directionToFace ?dir)
        (uninferredSentence (facing ?dir))
        (hasMultipleOutputs unblocked)
        (directionToFaceWithNearestPellet ?dir)
)

;; CONSIDERING NEAREST PELLET
(<== (nearestPelletAndUnblocked ?dir)
        (nearestPellet ?dir)
        (unblocked ?dir)
)

;; There's only one nearest pellet, so face it
(<== (directionToFaceWithNearestPellet ?dir)
        (uninferredSentence (hasMultipleOutputs nearestPelletAndUnblocked))
        (nearestPelletAndUnblocked ?dir)
)

;; There's more than one nearest pellet, so think about nearest ghost
(<== (directionToFaceWithNearestPellet ?dir)
        (hasMultipleOutputs nearestPelletAndUnblocked)
        (notNearestGhostAndNearestPelletAndUnblocked ?dir)
)

;; CONSIDERING NEAREST GHOST
(<== (notNearestGhostAndNearestPelletAndUnblocked ?dir)
        (nearestPellet ?dir)
        (unblocked ?dir)
        (uninferredSentence (nearestGhost ?dir))
)





;; preferInContext (if you have multiple which one to pick)