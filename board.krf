(in-microtheory PacPersonMt)
(genlMt PacPersonMt QualitativeMechanicsMt)

;; ontologize

(isa wall Predicate)
(arity wall 1)
(arg1Isa wall 2DNonDiagonal)
(comment wall "(wall ?direction) says that ?direction is a wall")

(isa facing Predicate)
(arity facing 1)
(arg1Isa facing 2DNonDiagonal)
(comment facing "(facing ?direction) says that PacPerson is facing ?direction")

(isa directionToFace Predicate)
(arity directionToFace 1)
(arg1Isa directionToFace 2DNonDiagonal)
(comment directionToFace "(directionToFace ?direction) says that PacPerson should next face ?direction")

(isa nearestPellet Predicate)
(arity nearestPellet 1)
(arg1Isa nearestPellet 2DNonDiagonal)
(comment nearestPellet "(nearestPellet ?direction) says that the nearest pellet is at ?direction. If multiple pellets are the same distance away, there will be multiple of these.")

(isa nearestGhost Predicate)
(arity nearestGhost 1)
(arg1Isa nearestGhost 2DNonDiagonal)
(comment nearestGhost "(nearestGhost ?direction) says that the nearest ghost is at ?direction. If multiple ghosts are the same distance away, there will be multiple of these.")

(<== (hasMultipleOutputs ?arity1Function)
        (?arity1Function ?output1)
        (?arity1Function ?output2)
        (different ?output1 ?output2)
)

;; Priorities:
;; at each level if there's just one option then we're done
;; 1. no ghost/no wall (not blocked)
;; 2. facing
;; 2. nearestPellet
;; 3. not nearestGhost

(<== (unblocked ?dir)
        (isa ?dir 2DNonDiagonal)
        (uninferredSentence (wall ?dir))
        (uninferredSentence (ghost ?dir))
)

;; CONSIDERING BLOCKED + FACING

;; There is one unblocked direction. Face it.
(<== (directionToFace ?dir)
        (unblocked ?dir)
        (uninferredSentence (hasMultipleOutputs unblocked))
)

;; You're facing an unblocked direction. Keep going.
(<== (directionToFace ?dir)
        (unblocked ?dir)
        (facing ?dir)
)

;; There is more than one unblocked direction. Think about nearest pellet.
(<== (directionToFace ?dir)
        (isa ?dir 2DNonDiagonal)
        (uninferredSentence (facing ?dir))
        (hasMultipleOutputs unblocked)
        (directionToFaceWithNearestPellet ?dir)
)

;; There is more than one unblocked direction but nearest pellet returns nothing
(<== (directionToFace ?dir)
        (isa ?dir 2DNonDiagonal)
        (uninferredSentence (facing ?dir))
        (hasMultipleOutputs unblocked)
        (uninferredSentence (directionToFaceWithNearestPellet ?dir))
        (unblocked ?dir)
)

;; CONSIDERING NEAREST PELLET
(<== (nearestPelletAndUnblocked ?dir)
        (nearestPellet ?dir)
        (unblocked ?dir)
)

;; There's only one nearest pellet, so face it
(<== (directionToFaceWithNearestPellet ?dir)
        (uninferredSentence (hasMultipleOutputs nearestPelletAndUnblocked))
        (nearestPelletAndUnblocked ?dir)
)

;; There's more than one nearest pellet, so think about nearest ghost
(<== (directionToFaceWithNearestPellet ?dir)
        (hasMultipleOutputs nearestPelletAndUnblocked)
        (notNearestGhostAndNearestPelletAndUnblocked ?dir)
)

;; There is more than one nearest pellet, but thinking about nearest ghost eliminates all options
(<== (directionToFace ?dir)
        (hasMultipleOutputs nearestPelletAndUnblocked)
        (uninferredSentence (notNearestGhostAndNearestPelletAndUnblocked ?dir))
        (nearestPelletAndUnblocked ?dir)
)


;; CONSIDERING NEAREST GHOST
(<== (notNearestGhostAndNearestPelletAndUnblocked ?dir)
        (isa ?dir 2DNonDiagonal)
        (nearestPellet ?dir)
        (unblocked ?dir)
        (uninferredSentence (nearestGhost ?dir))
)