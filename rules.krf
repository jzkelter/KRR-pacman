(in-microtheory PacPersonMt)
(genlMt PacPersonMt QualitativeMechanicsMt)

;;;ONTOLOGY DEFINITIONS
(isa wall Predicate)
(arity wall 1)
(arg1Isa wall 2DNonDiagonal)
(comment wall "(wall ?direction) says that ?direction is a wall")

(isa facing Predicate)
(arity facing 1)
(arg1Isa facing 2DNonDiagonal)
(comment facing "(facing ?direction) says that PacPerson is facing ?direction")

(isa directionToFace Predicate)
(arity directionToFace 1)
(arg1Isa directionToFace 2DNonDiagonal)
(comment directionToFace "(directionToFace ?direction) says that PacPerson should next face ?direction")

(isa nearestPellet Predicate)
(arity nearestPellet 1)
(arg1Isa nearestPellet 2DNonDiagonal)
(comment nearestPellet "(nearestPellet ?direction) says that the nearest pellet is at ?direction. If multiple pellets are the same distance away, there will be multiple of these.")

(isa nearestGhost Predicate)
(arity nearestGhost 1)
(arg1Isa nearestGhost 2DNonDiagonal)
(comment nearestGhost "(nearestGhost ?direction) says that the nearest ghost is at ?direction. If multiple ghosts are the same distance away, there will be multiple of these.")

;;;;;;;;;HELPERS;;;;


;;;Which directions are unblocked?
(<== (unblocked ?dir)
		(isa ?dir 2DNonDiagonal)
		(uninferredSentence (wall ?dir))
		(uninferredSentence (ghost ?dir))
)

;;;Returns all of the directions free of nearest ghosts
(<== (nearestGhostFree ?dir)
		(isa ?dir 2DNonDiagonal)
		(uninferredSentence (nearestGhost ?dir))
)


;;;;;;;;Rules;;;;;;

;;;Rule 1. If facing direction unblocked --> keep facing direction
(<== (rule1 ?dir)
		(unblocked ?dir)	;;;List of unblocked directions
		(facing ?dir)		;;;The direction PacPerson is facing
	;;;Result: If current_direction unblocked --> ?dir = current_direction
)

;;;Rule 2. If not Rule1, face direction that is (a) unblocked, (b) has nearestPellet, and (c) nearestGhostFree
(<== (rule2 ?dir)
		(uninferredSentence (rule1 ?dir))
		(unblocked ?dir)
		(nearestPellet ?dir)
		(nearestGhostFree ?dir)
)

;;;Rule 3. If not Rule1 and Rule 2, face direction that is (a) unblocked and (b) has nearestPellet
(<== (rule3 ?dir)
		(uninferredSentence (rule1 ?dir))
		(uninferredSentence (rule2 ?dir))
		(unblocked ?dir)
		(nearestPellet ?dir)
)

;;;Rule 4. If not Rule 1 and Rule 2 and Rule 3, face direction that is (a) unblocked and (c) nearestGhostFree
(<== (rule4 ?dir)
		(uninferredSentence (rule1 ?dir))
		(uninferredSentence (rule2 ?dir))
		(uninferredSentence (rule3 ?dir))
		(unblocked ?dir)
		(nearestGhostFree ?dir)
)

;;;Rule 5. If not Rules 1-4, face direction that is (a) unblocked
(<== (rule5 ?dir)
		(uninferredSentence (rule1 ?dir))
		(uninferredSentence (rule2 ?dir))
		(uninferredSentence (rule3 ?dir))
		(uninferredSentence (rule4 ?dir))
		(unblocked ?dir)
)


;;;ENTRY POINT FOR QUERY FROM NETLOGO
(<== (directionToFace ?dir)
		(rule1 ?dir)
)
(<== (directionToFace ?dir)
		(rule2 ?dir)
)
(<== (directionToFace ?dir)
		(rule3 ?dir)
)
(<== (directionToFace ?dir)
		(rule4 ?dir)
)
(<== (directionToFace ?dir)
		(rule5 ?dir)
)



;;;;;;;;UNUSED HELPERS;;;;;
;;;Does this function have multiple outputs
(<== (hasMultipleOutputs ?arity1Function ?outputType)
        (?arity1Function ?output1)
        (isa ?output1 ?outputType)
        
        (?arity1Function ?output2)
        (isa ?output2 ?outputType)
        
        (different ?output1 ?output2)
)

;;;Does this function have only one output?
(<== (hasOneOutput ?arity1Function ?outputType)
		(?arity1Function ?output1) 				;;;Function has an output
		(isa ?output1 ?outputType)				;;;Output matches the output type (basically is not null)
		(not (hasMultipleOutputs ?arity1Function ?outputType))
)

;;;;;Blocked helpers



;;;Returns an unblocked direction if there is only one available.
(<== (one_unblocked ?dir)
		(isa ?dir 2DNonDiagonal)
		(hasOneOutput unblocked 2DNonDiagonal)
		(unblocked ?dir)
)

;;;Pellet helpers

;;;Which directions have valid (unblocked) nearestPellets?
(<== (unblockedNearestPellets ?dir)
		(isa ?dir 2DNonDiagonal)
		(unblocked ?dir)
		(nearestPellet ?dir)
)

;;;Returns an unblocked nearest pellet if only one is available.
(<== (one_unblocked_nearest_pellet ?dir)
		(isa ?dir 2DNonDiagonal)
		(hasOneOutput unblockedNearestPellets 2DNonDiagonal)
		(unblockedNearestPellets ?dir)
)

;;;Ghost helpers

;;;Returns any direction with no block or nearestGhosts
(<== (unblockedAndNoNearestGhosts ?dir)
		(isa ?dir 2DNonDiagonal)
		(unblocked ?dir)
		(uninferredSentence (nearestGhost ?dir))
)



